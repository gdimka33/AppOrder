import tkinter as tk
from tkinter import ttk
from logger import logger
from БД_соединение import выполнить_запрос
from кл_ИнформационноеОкно import ИнформационноеОкно

class ДобавлениеСотрудника(ttk.Frame):
    """
    Класс для отображения формы добавления сотрудника.
    Динамически создает поля ввода в зависимости от типа сотрудника.
    """
    def __init__(self, родитель, тип_сотрудника, callback=None):
        """
        Инициализация формы добавления сотрудника
        
        Args:
            родитель: Родительский виджет, в котором будет отображаться форма
            тип_сотрудника: Тип сотрудника (офицер/курсант)
            callback: Функция обратного вызова после успешного добавления
        """
        super().__init__(родитель)
        self.родитель = родитель
        self.тип_сотрудника = тип_сотрудника
        self.callback = callback
        self.поля_ввода = {}  # Словарь для хранения виджетов полей ввода
        
        # Растягиваем фрейм на всю ширину и высоту родительского контейнера
        self.pack(fill='both', expand=True)
        
        # Получаем структуру полей из базы данных
        self.структура_полей = self._получить_структуру_полей()
        
        # Создаем содержимое формы
        self._создать_содержимое()
        
        logger.info(f"Отображена форма добавления сотрудника типа: {тип_сотрудника}")
    
    def _получить_структуру_полей(self):
        """Получает структуру полей из базы данных для указанного типа сотрудника"""
        try:
            # Определяем таблицу в зависимости от типа сотрудника
            таблица = "офицеры" if self.тип_сотрудника == "офицер" else "курсанты"
            
            # Запрос для получения информации о столбцах таблицы
            запрос = f"PRAGMA table_info({таблица})"
            результат = выполнить_запрос(запрос)
            
            # Проверяем, что результат не None и не пустой
            if not результат:
                logger.error(f"Не удалось получить структуру таблицы {таблица}")
                return self._создать_структуру_на_основе_схемы()
            
            # Получаем справочные данные для выпадающих списков
            звания = self._получить_справочник("звания", "наименование", f"категория IN ('{self.тип_сотрудника}', 'общее')")
            должности = self._получить_справочник("должности", "наименование")
            подразделения = self._получить_справочник("подразделения", "наименование")
            
            # Формируем структуру полей
            структура = []
            for поле in результат:
                имя_поля = поле['name']
                # Пропускаем id и служебные поля
                if имя_поля == 'id' or имя_поля.startswith('_') or имя_поля.endswith('_id') or имя_поля.startswith('состояние_'):
                    continue
                    
                тип_поля = поле['type'].upper()
                обязательное = поле['notnull'] == 1
                структура.append({
                    'имя': имя_поля,
                    'тип': тип_поля,
                    'обязательное': обязательное,
                    'метка': self._форматировать_метку(имя_поля)
                })
            
            # Добавляем поля для внешних ключей (справочников)
            структура.append({
                'имя': 'звание',
                'тип': 'REFERENCE',
                'обязательное': True,
                'метка': 'Звание',
                'справочник': звания
            })
            
            структура.append({
                'имя': 'должность',
                'тип': 'REFERENCE',
                'обязательное': True,
                'метка': 'Должность',
                'справочник': должности
            })
            
            структура.append({
                'имя': 'подразделение',
                'тип': 'REFERENCE',
                'обязательное': True,
                'метка': 'Подразделение',
                'справочник': подразделения
            })
            
            # Для курсантов добавляем поле год набора
            if self.тип_сотрудника == "курсант":
                структура.append({
                    'имя': 'год_набора',
                    'тип': 'INTEGER',
                    'обязательное': True,
                    'метка': 'Год набора'
                })
            
            return структура
                
        except Exception as e:
            logger.error(f"Ошибка при получении структуры полей: {e}")
            # Возвращаем базовую структуру полей
            return self._создать_структуру_на_основе_схемы()
    
    def _получить_справочник(self, таблица, поле_значения, условие=None):
        """Получает данные из справочной таблицы"""
        try:
            запрос = f"SELECT id, {поле_значения} FROM {таблица}"
            if условие:
                запрос += f" WHERE {условие}"
            запрос += f" ORDER BY {поле_значения}"
            
            результат = выполнить_запрос(запрос)
            if результат:
                return [(строка['id'], строка[поле_значения]) for строка in результат]
            return []
        except Exception as e:
            logger.error(f"Ошибка при получении справочника {таблица}: {e}")
            return []
    
    def _создать_структуру_на_основе_схемы(self):
        """Создает структуру полей на основе схемы таблиц"""
        базовая_структура = [
            {'имя': 'фамилия', 'тип': 'TEXT', 'обязательное': True, 'метка': 'Фамилия'},
            {'имя': 'имя', 'тип': 'TEXT', 'обязательное': True, 'метка': 'Имя'},
            {'имя': 'отчество', 'тип': 'TEXT', 'обязательное': False, 'метка': 'Отчество'},
        ]
        
        # Получаем справочные данные
        звания = self._получить_справочник("звания", "наименование", f"категория IN ('{self.тип_сотрудника}', 'общее')")
        должности = self._получить_справочник("должности", "наименование")
        подразделения = self._получить_справочник("подразделения", "наименование")
        
        # Добавляем справочные поля
        базовая_структура.extend([
            {'имя': 'звание', 'тип': 'REFERENCE', 'обязательное': True, 'метка': 'Звание', 'справочник': звания},
            {'имя': 'должность', 'тип': 'REFERENCE', 'обязательное': True, 'метка': 'Должность', 'справочник': должности},
            {'имя': 'подразделение', 'тип': 'REFERENCE', 'обязательное': True, 'метка': 'Подразделение', 'справочник': подразделения}
        ])
        
        # Для курсантов добавляем поле год набора
        if self.тип_сотрудника == "курсант":
            базовая_структура.append({
                'имя': 'год_набора', 'тип': 'INTEGER', 'обязательное': True, 'метка': 'Год набора'
            })
        
        return базовая_структура
    
    def _форматировать_метку(self, имя_поля):
        """Форматирует имя поля для отображения в виде метки"""
        # Заменяем подчеркивания на пробелы и делаем первую букву заглавной
        метка = имя_поля.replace('_', ' ').capitalize()
        return метка
    
    def _создать_содержимое(self):
        """Создает содержимое формы добавления сотрудника"""
        # Создаем фрейм для содержимого с отступами
        фрейм_содержимого = ttk.Frame(self, padding=20)
        фрейм_содержимого.pack(fill='both', expand=True)
        
        # Заголовок формы
        заголовок = f"Добавление {'офицера' if self.тип_сотрудника == 'офицер' else 'курсанта'}"
        ttk.Label(фрейм_содержимого, text=заголовок, font=("TkDefaultFont", 14, "bold")).pack(pady=(0, 20))
        
        # Проверяем, есть ли поля для отображения
        if not self.структура_полей:
            # Показываем сообщение об ошибке
            ttk.Label(фрейм_содержимого, text="Не удалось получить структуру полей из базы данных", 
                     foreground="red").pack(pady=10)
            ttk.Button(фрейм_содержимого, text="Закрыть", 
                    command=self._отмена).pack(pady=10)
            return
        
        # Создаем фрейм для полей ввода (без прокрутки)
        фрейм_полей = ttk.Frame(фрейм_содержимого)
        фрейм_полей.pack(fill="both", expand=True, pady=(0, 20))
        
        # Создаем поля ввода на основе структуры
        for i, поле in enumerate(self.структура_полей):
            фрейм_поля = ttk.Frame(фрейм_полей)
            фрейм_поля.pack(fill="x", pady=5)
            
            # Метка поля с отметкой об обязательности
            текст_метки = f"{поле['метка']}{'*' if поле['обязательное'] else ''}:"
            ttk.Label(фрейм_поля, text=текст_метки, width=20).pack(side="left")
            
            # Создаем соответствующий виджет ввода в зависимости от типа поля
            if поле['тип'] == 'TEXT':
                виджет = ttk.Entry(фрейм_поля, width=40)
                виджет.pack(side="left", fill="x", expand=True)
            elif поле['тип'] == 'INTEGER':
                виджет = ttk.Spinbox(фрейм_поля, from_=0, to=100, width=10)
                виджет.pack(side="left")
            elif поле['тип'] == 'REAL':
                виджет = ttk.Entry(фрейм_поля, width=15)
                виджет.pack(side="left")
            elif поле['тип'] == 'DATE':
                фрейм_даты = ttk.Frame(фрейм_поля)
                фрейм_даты.pack(side="left")
                день = ttk.Spinbox(фрейм_даты, from_=1, to=31, width=3)
                месяц = ttk.Spinbox(фрейм_даты, from_=1, to=12, width=3)
                год = ttk.Spinbox(фрейм_даты, from_=1950, to=2050, width=5)
                день.pack(side="left", padx=2)
                ttk.Label(фрейм_даты, text=".").pack(side="left")
                месяц.pack(side="left", padx=2)
                ttk.Label(фрейм_даты, text=".").pack(side="left")
                год.pack(side="left", padx=2)
                виджет = (день, месяц, год)
            elif поле['тип'] == 'REFERENCE':
                # Создаем выпадающий список для справочных данных
                значения = [значение for _, значение in поле.get('справочник', [])]
                виджет = ttk.Combobox(фрейм_поля, values=значения, width=30, state="readonly")
                if значения:
                    виджет.current(0)  # Устанавливаем первое значение по умолчанию
                виджет.pack(side="left")
            else:
                виджет = ttk.Entry(фрейм_поля, width=40)
                виджет.pack(side="left", fill="x", expand=True)
            
            # Сохраняем виджет в словаре
            self.поля_ввода[поле['имя']] = виджет
        
        # Фрейм для кнопок
        фрейм_кнопок = ttk.Frame(фрейм_содержимого)
        фрейм_кнопок.pack(side="bottom", fill="x", pady=10)
        
        # Создаем центрирующий контейнер
        центр_контейнер = ttk.Frame(фрейм_кнопок)
        центр_контейнер.pack(anchor="center")
        
        # Кнопки Сохранить и Отмена - размещаем рядом по центру внизу
        ttk.Button(центр_контейнер, text="Сохранить", command=self._сохранить_сотрудника).pack(side="left", padx=5)
        ttk.Button(центр_контейнер, text="Отмена", command=self._отмена).pack(side="left", padx=5)
    
    def _сохранить_сотрудника(self):
        """Обрабатывает сохранение данных сотрудника в базу данных"""
        try:
            # Проверяем заполнение обязательных полей
            for поле in self.структура_полей:
                if поле['обязательное']:
                    значение = self._получить_значение_поля(поле['имя'])
                    if not значение:
                        self._показать_ошибку(f"Поле '{поле['метка']}' обязательно для заполнения!")
                        return
            
            # Собираем данные из полей ввода
            данные = {}
            for поле in self.структура_полей:
                имя_поля = поле['имя']
                
                # Для справочных полей получаем id
                if поле['тип'] == 'REFERENCE':
                    значение = self._получить_значение_поля(имя_поля)
                    if значение:
                        # Находим id по значению
                        for id_значения, текст_значения in поле.get('справочник', []):
                            if текст_значения == значение:
                                данные[f"{имя_поля}_id"] = id_значения
                                break
                else:
                    данные[имя_поля] = self._получить_значение_поля(имя_поля)
            
            # Определяем таблицу в зависимости от типа сотрудника
            таблица = "офицеры" if self.тип_сотрудника == "офицер" else "курсанты"
            
            # Формируем SQL запрос для вставки
            имена_полей = ", ".join(данные.keys())
            заполнители = ", ".join(["?" for _ in данные])
            значения = list(данные.values())
            
            запрос = f"INSERT INTO {таблица} ({имена_полей}) VALUES ({заполнители})"
            выполнить_запрос(запрос, значения)
            
            # Показываем информационное окно об успешном добавлении
            форматированный_текст = [
                ("Сотрудник успешно добавлен!\n", ["header", "green"]),
                (f"Данные {'офицера' if self.тип_сотрудника == 'офицер' else 'курсанта'} сохранены в базе данных.", [])
            ]
            
            # Очищаем текущий фрейм
            for виджет in self.winfo_children():
                виджет.destroy()
            
            # Показываем информационное окно и вызываем callback при закрытии
            ИнформационноеОкно(self, форматированный_текст, тип_окна="ок", callback=self._после_сохранения)
            
        except Exception as e:
            logger.error(f"Ошибка при сохранении сотрудника: {e}")
            self._показать_ошибку(f"Ошибка при сохранении: {str(e)}")
    
    def _получить_значение_поля(self, имя_поля):
        """Получает значение из поля ввода с учетом типа виджета"""
        виджет = self.поля_ввода.get(имя_поля)
        if not виджет:
            return None
        
        # Если это кортеж виджетов (для даты)
        if isinstance(виджет, tuple):
            день = виджет[0].get()
            месяц = виджет[1].get()
            год = виджет[2].get()
            if день and месяц and год:
                # Форматируем дату в формате YYYY-MM-DD
                return f"{год}-{месяц.zfill(2)}-{день.zfill(2)}"
            return None
        
        # Для обычных виджетов
        return виджет.get()
    
    def _показать_ошибку(self, сообщение):
        """Показывает информационное окно с сообщением об ошибке"""
        форматированный_текст = [
            ("Ошибка!\n", ["header", "red"]),
            (сообщение, ["red"])
        ]
        ИнформационноеОкно(self, форматированный_текст)
    
    def _отмена(self):
        """Обрабатывает отмену добавления сотрудника"""
        # Очищаем текущий фрейм
        for виджет in self.winfo_children():
            виджет.destroy()
        
        # Вызываем callback, если он задан
        if self.callback:
            self.callback(False)
    
    def _после_сохранения(self, _):
        """Вызывается после закрытия информационного окна об успешном сохранении"""
        # Вызываем callback, если он задан
        if self.callback:
            self.callback(True)
import tkinter as tk
from tkinter import ttk
from logger import logger
from БД_соединение import выполнить_запрос
from кл_ИнформационноеОкно import ИнформационноеОкно
# Import the widgets from their respective files
from ви_КомбобоксЗвание import ВиджетЗвания
from ви_КомбобоксДолжность import ВиджетДолжности
from ви_КомбобоксПодразделение import ВиджетПодразделения
from ви_ГодПоступления import ВиджетГодПоступления

# This file now serves as a central import point for all widgets
# You can add more widget imports here as needed

class ДобавлениеСотрудника(ttk.Frame):
    """
    Класс для отображения формы добавления сотрудника.
    Динамически создает поля ввода в зависимости от типа сотрудника.
    """
    def __init__(self, родитель, тип_сотрудника, callback=None):
        """
        Инициализация формы добавления сотрудника
        
        Args:
            родитель: Родительский виджет, в котором будет отображаться форма
            тип_сотрудника: Тип сотрудника (офицер/курсант)
            callback: Функция обратного вызова после успешного добавления
        """
        super().__init__(родитель)
        self.родитель = родитель
        self.тип_сотрудника = тип_сотрудника
        self.callback = callback
        self.поля_ввода = {}  # Словарь для хранения виджетов полей ввода
        
        # Растягиваем фрейм на всю ширину и высоту родительского контейнера
        self.pack(fill='both', expand=True)
        
        # Получаем структуру полей из базы данных
        self.структура_полей = self._получить_структуру_полей()
        
        # Создаем содержимое формы
        self._создать_содержимое()
        
        logger.info(f"Отображена форма добавления сотрудника типа: {тип_сотрудника}")
    
    def _получить_структуру_полей(self):
        """Получает структуру полей из базы данных для указанного типа сотрудника"""
        try:
            # Определяем таблицу в зависимости от типа сотрудника
            таблица = "офицеры" if self.тип_сотрудника == "офицер" else "курсанты"
            
            # Пробуем получить структуру таблицы более надежным способом
            try:
                # Сначала пробуем PRAGMA table_info
                запрос = f"PRAGMA table_info({таблица})"
                результат = выполнить_запрос(запрос)
                
                # Если результат пустой, пробуем альтернативный метод
                if not результат:
                    # Получаем одну запись для анализа структуры (или пустую структуру, если таблица пуста)
                    запрос = f"SELECT * FROM {таблица} LIMIT 1"
                    результат_запроса = выполнить_запрос(запрос)
                    
                    # Если таблица пуста, создаем пустую запись для получения структуры
                    if not результат_запроса:
                        # Получаем имена столбцов из запроса CREATE TABLE
                        for имя, sql in выполнить_запрос("SELECT name, sql FROM sqlite_master WHERE type='table' AND name=?", (таблица,)):
                            if sql:
                                # Парсим SQL запрос для получения имен столбцов
                                колонки = []
                                # Извлекаем текст между скобками
                                скобки_содержимое = sql[sql.find('(')+1:sql.rfind(')')]
                                # Разбиваем на строки по запятым, игнорируя запятые внутри скобок
                                строки = []
                                уровень_скобок = 0
                                текущая_строка = ""
                                for символ in скобки_содержимое:
                                    if символ == '(':
                                        уровень_скобок += 1
                                    elif символ == ')':
                                        уровень_скобок -= 1
                                    
                                    if символ == ',' and уровень_скобок == 0:
                                        строки.append(текущая_строка.strip())
                                        текущая_строка = ""
                                    else:
                                        текущая_строка += символ
                                
                                if текущая_строка.strip():
                                    строки.append(текущая_строка.strip())
                                
                                # Извлекаем имена и типы столбцов
                                for строка in строки:
                                    части = строка.strip().split()
                                    if части and not строка.strip().startswith(('PRIMARY', 'FOREIGN', 'CONSTRAINT')):
                                        имя_колонки = части[0]
                                        тип_колонки = части[1] if len(части) > 1 else "TEXT"
                                        обязательное = "NOT NULL" in строка.upper()
                                        колонки.append({
                                            'name': имя_колонки,
                                            'type': тип_колонки,
                                            'notnull': 1 if обязательное else 0
                                        })
                                
                                результат = колонки
                                break
            except Exception as e:
                logger.error(f"Ошибка при получении структуры таблицы {таблица}: {e}")
                return self._создать_структуру_на_основе_схемы()
            
            # Проверяем, что результат не None и не пустой
            if not результат:
                logger.error(f"Не удалось получить структуру таблицы {таблица}")
                return self._создать_структуру_на_основе_схемы()
            
            # Получаем справочные данные для выпадающих списков
            звания = self._получить_справочник("звания", "наименование", f"категория IN ('{self.тип_сотрудника}', 'общее')")
            должности = self._получить_справочник("должности", "наименование", f"категория IN ('{self.тип_сотрудника}', 'общее')")
            подразделения = self._получить_справочник("подразделения", "наименование")
            
            # Формируем структуру полей
            структура = []
            существующие_поля = set()  # Для отслеживания уже добавленных полей
            
            for поле in результат:
                имя_поля = поле['name']
                # Пропускаем id, служебные поля и поле звание_id (будем добавлять его отдельно)
                if имя_поля == 'id' or имя_поля.startswith('_') or имя_поля.endswith('_id') or имя_поля.startswith('состояние_'):
                    continue
                    
                тип_поля = поле['type'].upper()
                обязательное = поле['notnull'] == 1
                структура.append({
                    'имя': имя_поля,
                    'тип': тип_поля,
                    'обязательное': обязательное,
                    'метка': self._форматировать_метку(имя_поля)
                })
                существующие_поля.add(имя_поля)
            
            # Добавляем поля для внешних ключей (справочников)
            if 'звание' not in существующие_поля:
                структура.append({
                    'имя': 'звание',
                    'тип': 'REFERENCE',
                    'обязательное': True,
                    'метка': 'Звание',
                    'справочник': звания
                })
                существующие_поля.add('звание')
            
            # Меняем порядок - сначала подразделение, потом должность
            if 'подразделение' not in существующие_поля:
                структура.append({
                    'имя': 'подразделение',
                    'тип': 'REFERENCE',
                    'обязательное': True,
                    'метка': 'Подразделение',
                    'справочник': подразделения
                })
                существующие_поля.add('подразделение')
            
            if 'должность' not in существующие_поля:
                структура.append({
                    'имя': 'должность',
                    'тип': 'REFERENCE',
                    'обязательное': True,
                    'метка': 'Должность',
                    'справочник': должности
                })
                существующие_поля.add('должность')
            
            # Добавляем поля СОД и ПСОД для офицеров
            if self.тип_сотрудника == "офицер":
                if 'сод' not in существующие_поля:
                    структура.append({
                        'имя': 'сод',
                        'тип': 'BOOLEAN',
                        'обязательное': False,
                        'метка': 'СОД'
                    })
                    существующие_поля.add('сод')
                
                if 'псод' not in существующие_поля:
                    структура.append({
                        'имя': 'псод',
                        'тип': 'BOOLEAN',
                        'обязательное': False,
                        'метка': 'ПСОД'
                    })
                    существующие_поля.add('псод')
            # Для курсантов добавляем только ПСОД
            elif self.тип_сотрудника == "курсант":
                if 'псод' not in существующие_поля:
                    структура.append({
                        'имя': 'псод',
                        'тип': 'BOOLEAN',
                        'обязательное': False,
                        'метка': 'ПСОД'
                    })
                    существующие_поля.add('псод')
            
            # Для курсантов добавляем поле год набора
            if self.тип_сотрудника == "курсант" and 'год_набора' not in существующие_поля:
                структура.append({
                    'имя': 'год_набора',
                    'тип': 'INTEGER',
                    'обязательное': True,
                    'метка': 'Год набора'
                })
            
            return структура
            
        except Exception as e:
            logger.error(f"Ошибка при получении структуры полей: {e}")
            # Возвращаем базовую структуру полей
            return self._создать_структуру_на_основе_схемы()
    
    def _получить_справочник(self, таблица, поле_значения, условие=None):
        """Получает данные из справочной таблицы"""
        try:
            запрос = f"SELECT id, {поле_значения} FROM {таблица}"
            if условие:
                запрос += f" WHERE {условие}"
            запрос += f" ORDER BY {поле_значения}"
            
            результат = выполнить_запрос(запрос)
            if результат:
                return [(строка['id'], строка[поле_значения]) for строка in результат]
            return []
        except Exception as e:
            logger.error(f"Ошибка при получении справочника {таблица}: {e}")
            return []
    
    def _создать_структуру_на_основе_схемы(self):
        """Создает структуру полей на основе схемы таблиц"""
        базовая_структура = [
            {'имя': 'фамилия', 'тип': 'TEXT', 'обязательное': True, 'метка': 'Фамилия'},
            {'имя': 'имя', 'тип': 'TEXT', 'обязательное': True, 'метка': 'Имя'},
            {'имя': 'отчество', 'тип': 'TEXT', 'обязательное': False, 'метка': 'Отчество'},
        ]
        
        # Получаем справочные данные
        звания = self._получить_справочник("звания", "наименование", f"категория IN ('{self.тип_сотрудника}', 'общее')")
        должности = self._получить_справочник("должности", "наименование", f"категория IN ('{self.тип_сотрудника}', 'общее')")
        подразделения = self._получить_справочник("подразделения", "наименование")
        
        # Добавляем справочные поля - меняем порядок должности и подразделения
        базовая_структура.extend([
            {'имя': 'звание', 'тип': 'REFERENCE', 'обязательное': True, 'метка': 'Звание', 'справочник': звания},
            {'имя': 'подразделение', 'тип': 'REFERENCE', 'обязательное': True, 'метка': 'Подразделение', 'справочник': подразделения},
            {'имя': 'должность', 'тип': 'REFERENCE', 'обязательное': True, 'метка': 'Должность', 'справочник': должности}
        ])
        
        # Добавляем поля СОД и ПСОД для офицеров
        if self.тип_сотрудника == "офицер":
            базовая_структура.extend([
                {'имя': 'сод', 'тип': 'BOOLEAN', 'обязательное': False, 'метка': 'СОД'},
                {'имя': 'псод', 'тип': 'BOOLEAN', 'обязательное': False, 'метка': 'ПСОД'}
            ])
        # Для курсантов добавляем только ПСОД
        elif self.тип_сотрудника == "курсант":
            базовая_структура.append({
                'имя': 'псод', 'тип': 'BOOLEAN', 'обязательное': False, 'метка': 'ПСОД'
            })
        
        # Для курсантов добавляем поле год набора
        if self.тип_сотрудника == "курсант":
            базовая_структура.append({
                'имя': 'год_набора', 'тип': 'INTEGER', 'обязательное': True, 'метка': 'Год набора'
            })
        
        return базовая_структура
    
    def _форматировать_метку(self, имя_поля):
        """Форматирует имя поля для отображения в виде метки"""
        # Заменяем подчеркивания на пробелы и делаем первую букву заглавной
        метка = имя_поля.replace('_', ' ').capitalize()
        return метка
    
    def _создать_содержимое(self):
        """Создает содержимое формы добавления сотрудника"""
        # Создаем фрейм для содержимого с отступами
        фрейм_содержимого = ttk.Frame(self, padding=20)
        фрейм_содержимого.pack(fill='both', expand=True)
        
        # Заголовок формы
        заголовок = f"Добавление {'офицера' if self.тип_сотрудника == 'офицер' else 'курсанта'}"
        ttk.Label(фрейм_содержимого, text=заголовок, font=("TkDefaultFont", 14, "bold")).pack(pady=(0, 20))
        
        # Проверяем, есть ли поля для отображения
        if not self.структура_полей:
            # Показываем сообщение об ошибке
            ttk.Label(фрейм_содержимого, text="Не удалось получить структуру полей из базы данных", 
                     foreground="red").pack(pady=10)
            ttk.Button(фрейм_содержимого, text="Закрыть", 
                    command=self._отмена).pack(pady=10)
            return
        
        # Создаем основной контейнер для полей и кнопок
        основной_контейнер = ttk.Frame(фрейм_содержимого)
        основной_контейнер.pack(fill="both", expand=True)
        
        # Создаем фрейм для полей ввода (без прокрутки)
        фрейм_полей = ttk.Frame(основной_контейнер)
        фрейм_полей.pack(side="left", fill="both", expand=True, pady=(0, 20))
        
        # Создаем фрейм для кнопок справа
        фрейм_кнопок = ttk.Frame(основной_контейнер, padding=(10, 0, 0, 0))
        фрейм_кнопок.pack(side="right", fill="y", padx=5)
        
        # Кнопки Сохранить и Отмена - размещаем вертикально справа
        ttk.Button(фрейм_кнопок, text="Сохранить", command=self._сохранить_сотрудника).pack(fill="x", pady=5)
        ttk.Button(фрейм_кнопок, text="Отмена", command=self._отмена).pack(fill="x", pady=5)
        
        # Реорганизуем структуру полей для курсантов
        отображаемые_поля = []
        поле_год_набора = None
        
        for поле in self.структура_полей:
            # Для курсантов пропускаем поле подразделение
            if self.тип_сотрудника == "курсант" and поле['имя'] == 'подразделение':
                continue
            
            # Сохраняем поле год_набора отдельно для курсантов
            if self.тип_сотрудника == "курсант" and поле['имя'] == 'год_набора':
                поле_год_набора = поле
                continue
                
            отображаемые_поля.append(поле)
        
        # Для курсантов добавляем поле год_набора после должности
        if self.тип_сотрудника == "курсант" and поле_год_набора:
            должность_индекс = next((i for i, поле in enumerate(отображаемые_поля) if поле['имя'] == 'должность'), -1)
            if должность_индекс != -1:
                отображаемые_поля.insert(должность_индекс + 1, поле_год_набора)
            else:
                отображаемые_поля.append(поле_год_набора)
        
        # Создаем поля ввода на основе реорганизованной структуры
        for i, поле in enumerate(отображаемые_поля):
            фрейм_поля = ttk.Frame(фрейм_полей)
            фрейм_поля.pack(fill="x", pady=5)
            
            # Метка поля с отметкой об обязательности
            текст_метки = f"{поле['метка']}{'*' if поле['обязательное'] else ''}:"
            ttk.Label(фрейм_поля, text=текст_метки, width=20).pack(side="left")
            
            # Создаем соответствующий виджет ввода в зависимости от типа поля
            if поле['имя'] == 'звание':
                # Используем наш кастомный виджет для звания
                виджет = ВиджетЗвания(фрейм_поля, self.тип_сотрудника)
                виджет.pack(side="left", fill="x", expand=True)
            elif поле['имя'] == 'должность':
                # Используем наш кастомный виджет для должности
                виджет = ВиджетДолжности(фрейм_поля, self.тип_сотрудника)
                виджет.pack(side="left", fill="x", expand=True)
            elif поле['имя'] == 'подразделение':
                # Используем наш кастомный виджет для подразделения
                виджет = ВиджетПодразделения(фрейм_поля)
                виджет.pack(side="left", fill="x", expand=True)
            elif поле['имя'] == 'год_набора':
                # Используем наш кастомный виджет для года поступления
                виджет = ВиджетГодПоступления(фрейм_поля)
                виджет.pack(side="left", fill="x")
            elif поле['тип'] == 'BOOLEAN' or поле['имя'] in ['сод', 'псод']:
                # Создаем переменную для хранения состояния чекбокса
                переменная = tk.BooleanVar(value=False)
                виджет = ttk.Checkbutton(фрейм_поля, variable=переменная)
                виджет.pack(side="left")
                # Сохраняем переменную вместе с виджетом для доступа к значению
                виджет.var = переменная
            elif поле['тип'] == 'TEXT':
                виджет = ttk.Entry(фрейм_поля, width=40)
                виджет.pack(side="left", fill="x", expand=True)
            elif поле['тип'] == 'INTEGER' and поле['имя'] != 'год_набора':  # Исключаем год_набора
                виджет = ttk.Spinbox(фрейм_поля, from_=0, to=100, width=10)
                виджет.pack(side="left")
            elif поле['тип'] == 'REAL':
                виджет = ttk.Entry(фрейм_поля, width=15)
                виджет.pack(side="left")
            elif поле['тип'] == 'DATE':
                фрейм_даты = ttk.Frame(фрейм_поля)
                фрейм_даты.pack(side="left")
                день = ttk.Spinbox(фрейм_даты, from_=1, to=31, width=3)
                месяц = ttk.Spinbox(фрейм_даты, from_=1, to=12, width=3)
                год = ttk.Spinbox(фрейм_даты, from_=1950, to=2050, width=5)
                день.pack(side="left", padx=2)
                ttk.Label(фрейм_даты, text=".").pack(side="left")
                месяц.pack(side="left", padx=2)
                ttk.Label(фрейм_даты, text=".").pack(side="left")
                год.pack(side="left", padx=2)
                виджет = (день, месяц, год)
            elif поле['тип'] == 'REFERENCE':
                # Создаем выпадающий список для справочных данных
                значения = [значение for _, значение in поле.get('справочник', [])]
                виджет = ttk.Combobox(фрейм_поля, values=значения, width=30, state="readonly")
                if значения:
                    виджет.current(0)
                виджет.pack(side="left")
            else:
                виджет = ttk.Entry(фрейм_поля, width=40)
                виджет.pack(side="left", fill="x", expand=True)
            
            # Сохраняем виджет в словаре для последующего доступа при сохранении данных
            self.поля_ввода[поле['имя']] = виджет
        
        # Удаляем старый фрейм для кнопок и связанный с ним код
        # фрейм_кнопок = ttk.Frame(фрейм_содержимого)
        # фрейм_кнопок.pack(side="bottom", fill="x", pady=10)
        
        # # Создаем центрирующий контейнер
        # центр_контейнер = ttk.Frame(фрейм_кнопок)
        # центр_контейнер.pack(anchor="center")
        
        # # Кнопки Сохранить и Отмена - размещаем рядом по центру внизу
        # ttk.Button(центр_контейнер, text="Сохранить", command=self._сохранить_сотрудника).pack(side="left", padx=5)
        # ttk.Button(центр_контейнер, text="Отмена", command=self._отмена).pack(side="left", padx=5)
    
    def _сохранить_сотрудника(self):
        """Обрабатывает сохранение данных сотрудника в базу данных"""
        try:
            # Проверяем заполнение обязательных полей
            for поле in self.структура_полей:
                # Пропускаем проверку поля подразделение для курсантов
                if self.тип_сотрудника == "курсант" and поле['имя'] == 'подразделение':
                    continue
                    
                if поле['обязательное']:
                    значение = self._получить_значение_поля(поле['имя'])
                    if not значение:
                        self._показать_ошибку(f"Поле '{поле['метка']}' обязательно для заполнения!")
                        return
            
            # Собираем данные из полей ввода
            данные = {}
            for поле in self.структура_полей:
                имя_поля = поле['имя']
                
                # Пропускаем поле подразделение для курсантов
                if self.тип_сотрудника == "курсант" and имя_поля == 'подразделение':
                    continue
                
                # Для справочных полей получаем id
                if поле['тип'] == 'REFERENCE':
                    if имя_поля in ['звание', 'должность', 'подразделение']:
                        # Для кастомных виджетов используем метод get_id()
                        виджет = self.поля_ввода.get(имя_поля)
                        if виджет:  # Проверяем, что виджет существует
                            данные[f"{имя_поля}_id"] = виджет.get_id()
                    else:
                        значение = self._получить_значение_поля(имя_поля)
                        if значение:
                            # Находим id по значению
                            for id_значения, текст_значения in поле.get('справочник', []):
                                if текст_значения == значение:
                                    данные[f"{имя_поля}_id"] = id_значения
                                    break
                # Для полей СОД и ПСОД используем правильные имена столбцов в БД
                elif имя_поля in ['сод', 'псод']:
                    данные[f"состояние_{имя_поля}"] = self._получить_значение_поля(имя_поля)
                else:
                    данные[имя_поля] = self._получить_значение_поля(имя_поля)
            
            # Определяем таблицу в зависимости от типа сотрудника
            таблица = "офицеры" if self.тип_сотрудника == "офицер" else "курсанты"
            
            # Формируем SQL запрос для вставки
            имена_полей = ", ".join(данные.keys())
            заполнители = ", ".join(["?" for _ in данные])
            значения = list(данные.values())
            
            запрос = f"INSERT INTO {таблица} ({имена_полей}) VALUES ({заполнители})"
            выполнить_запрос(запрос, значения)
            
            # Показываем информационное окно об успешном добавлении
            форматированный_текст = [
                ("Сотрудник успешно добавлен!\n", ["header", "green"]),
                (f"Данные {'офицера' if self.тип_сотрудника == 'офицер' else 'курсанта'} сохранены в базе данных.", [])
            ]
            
            # Очищаем текущий фрейм
            for виджет in self.winfo_children():
                виджет.destroy()
            
            # Показываем информационное окно и вызываем callback при закрытии
            ИнформационноеОкно(self, форматированный_текст, тип_окна="ок", callback=self._после_сохранения)
            
        except Exception as e:
            logger.error(f"Ошибка при сохранении сотрудника: {e}")
            self._показать_ошибку(f"Ошибка при сохранении: {str(e)}")
    
    def _получить_значение_поля(self, имя_поля):
        """Получает значение из поля ввода с учетом типа виджета"""
        виджет = self.поля_ввода.get(имя_поля)
        if not виджет:
            return None
        
        # Если это кортеж виджетов (для даты)
        if isinstance(виджет, tuple):
            день = виджет[0].get()
            месяц = виджет[1].get()
            год = виджет[2].get()
            if день and месяц and год:
                # Форматируем дату в формате YYYY-MM-DD
                return f"{год}-{месяц.zfill(2)}-{день.zfill(2)}"
            return None
        
        # Для чекбоксов (СОД и ПСОД)
        if имя_поля in ['сод', 'псод']:
            return 1 if виджет.var.get() else 0
        
        # Для виджета звания, должности, подразделения и года поступления
        if имя_поля in ['звание', 'должность', 'подразделение', 'год_набора']:
            return виджет.get()
        
        # Для обычных виджетов
        return виджет.get()
    
    def _показать_ошибку(self, сообщение):
        """Показывает информационное окно с сообщением об ошибке"""
        форматированный_текст = [
            ("Ошибка!\n", ["header", "red"]),
            (сообщение, ["red"])
        ]
        ИнформационноеОкно(self, форматированный_текст)
    
    def _отмена(self):
        """Обрабатывает отмену добавления сотрудника"""
        # Очищаем текущий фрейм
        for виджет in self.winfo_children():
            виджет.destroy()
        
        # Вызываем callback, если он задан
        if self.callback:
            self.callback(False)
    
    def _после_сохранения(self, _):
        """Вызывается после закрытия информационного окна об успешном сохранении"""
        # Вызываем callback, если он задан
        if self.callback:
            self.callback(True)